/**
 * Vector Search Tests
 * Tests for vector store, embedding generation, and similarity calculations
 */

import { generateMockDocuments } from '@/lib/rag/mock-data-generator';

describe('Vector Search', () => {
  describe('Mock Data Generator', () => {
    it('should generate mock documents', () => {
      const docs = generateMockDocuments();
      expect(docs).toBeDefined();
      expect(docs.length).toBeGreaterThan(0);
    });

    it('should generate documents with required fields', () => {
      const docs = generateMockDocuments();
      docs.forEach(doc => {
        expect(doc.id).toBeDefined();
        expect(doc.title).toBeDefined();
        expect(doc.content).toBeDefined();
        expect(typeof doc.id).toBe('string');
        expect(typeof doc.title).toBe('string');
        expect(typeof doc.content).toBe('string');
      });
    });

    it('should have unique document IDs', () => {
      const docs = generateMockDocuments();
      const ids = docs.map(doc => doc.id);
      const uniqueIds = new Set(ids);
      expect(uniqueIds.size).toBe(ids.length);
    });

    it('should have meaningful content', () => {
      const docs = generateMockDocuments();
      docs.forEach(doc => {
        expect(doc.content.length).toBeGreaterThan(50);
      });
    });
  });

  describe('Cosine Similarity', () => {
    it('should calculate cosine similarity correctly', () => {
      // Test vectors
      const v1 = [1, 0, 0];
      const v2 = [1, 0, 0];
      const v3 = [0, 1, 0];

      // Same vectors should have similarity of 1
      const similarity1 = cosineSimilarity(v1, v2);
      expect(similarity1).toBeCloseTo(1, 5);

      // Orthogonal vectors should have similarity of 0
      const similarity2 = cosineSimilarity(v1, v3);
      expect(similarity2).toBeCloseTo(0, 5);
    });

    it('should handle normalized vectors', () => {
      const v1 = [0.6, 0.8];
      const v2 = [0.6, 0.8];

      const similarity = cosineSimilarity(v1, v2);
      expect(similarity).toBeCloseTo(1, 5);
    });

    it('should throw error for different dimensions', () => {
      const v1 = [1, 0, 0];
      const v2 = [1, 0];

      expect(() => cosineSimilarity(v1, v2)).toThrow('Vectors must have the same dimension');
    });
  });

  describe('Vector Embedding Consistency', () => {
    it('should ensure all embeddings have same dimension', () => {
      // This test verifies that when embeddings are generated by GLM API,
      // they all have the same dimension (1024 for embedding-3)
      const expectedDimension = 1024;

      // Mock embeddings that would come from GLM API
      const mockEmbeddings = [
        new Array(expectedDimension).fill(0.1),
        new Array(expectedDimension).fill(0.2),
        new Array(expectedDimension).fill(0.3),
      ];

      mockEmbeddings.forEach(embedding => {
        expect(embedding.length).toBe(expectedDimension);
      });
    });
  });
});

/**
 * Helper function: Calculate cosine similarity between two vectors
 */
function cosineSimilarity(a: number[], b: number[]): number {
  if (a.length !== b.length) {
    throw new Error('Vectors must have the same dimension');
  }

  let dotProduct = 0;
  let normA = 0;
  let normB = 0;

  for (let i = 0; i < a.length; i++) {
    dotProduct += a[i] * b[i];
    normA += a[i] * a[i];
    normB += b[i] * b[i];
  }

  const denominator = Math.sqrt(normA) * Math.sqrt(normB);
  if (denominator === 0) {
    return 0;
  }

  return dotProduct / denominator;
}

